{"meta":{"title":"王智坚的秘密空间","subtitle":"","description":"","author":"王智坚","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-05-30T14:16:18.000Z","updated":"2022-05-30T14:17:18.300Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"面试-2022-6-9","slug":"面试-2022-6-9","date":"2022-06-11T09:45:52.000Z","updated":"2022-06-15T04:55:36.973Z","comments":true,"path":"2022/06/11/面试-2022-6-9/","link":"","permalink":"http://example.com/2022/06/11/%E9%9D%A2%E8%AF%95-2022-6-9/","excerpt":"","text":"Java八股文笔记（三）Java的23种设计模式单例模式​ 单例模式有以下特点： ​ 1、单例类只能有一个实例。 ​ 2、单例类必须自己创建自己的唯一实例。 ​ 3、单例类必须给所有其他对象提供这一实例。 ​ 单例模式分为饿汉式与懒汉式。 饿汉式 public class SingleTon&#123; protected SingleTon singleTon; private SingleTon()&#123; System.out.println(\"private SingleTon\"); &#125; public static SingleTon getInstance()&#123; if(singleTon == null)&#123; singleTon = new SingleTon(); &#125; return singleTon; &#125; &#125; 懒汉式 public class SingleTon&#123; protected SingleTon singleTon; private SingleTon()&#123; System.out.println(\"private SingleTon()\"); &#125; public static SingleTon getInstance()&#123; //双重检验机制 if(singleTon == null)&#123; synchronized(SingleTon.class)&#123; if(singleTOn == null)&#123; singleTon = new SingleTon(); &#125; &#125; &#125; return singleTon; &#125; &#125; ​ 单例模式真的是安全的吗？ ​ 我们学习过反射的知识，可以通过反射得到一个类的构造器，接着设置断言，将私有设置为公有，那么就可以通过newInstance得到一个新的对象。 public class Test&#123; public static void main(String[] args)&#123; //正常获取单例对象 SingleTon singleTon = SingleTon.getInstance(); //通过反射new一个对象 SingleTon reflactSingleTon = null; try&#123; Constructor&lt;SingleTon> constructor = SingleTon.class.getDeclaredConstructor(); constructor.setAccessible(true); reflactSingleTon = constructor.newInstance(); &#125;catch(NoSuchMethodException | SecurityException e)&#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println(singleTon); System.out.println(reflactSingleTon); &#125; &#125; ​ 执行结果为： ​ 可以看到，我们得到了两个不同的对象，单例对象被破坏了。那么我们如何保证其不被破坏呢？ ​ 而反射最后一步的操作中，newInstance是创建对象的关键，这时我们查看这个方法的源码，他抛出了这么一个异常 ​ “Cannot reflectively crete enum objects”，无法通过反射创建一个枚举类。、 ​ 枚举类才是真正的单例类。 工厂模式​ 获取对象时，直接从工厂中获取对象，无需知道创建对象时需要的参数。 ​ 工厂模式分类三类（简单工厂，方法工厂，抽象工厂）。 简单工厂模式 ​ 用来生产同一等级结构中的任意产品。 方法工厂模式 ​ 用来生产同一等级结构中的固定产品 抽象工厂模式 ​ 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂 简单工厂模式​ 例 ​ 可以看到当消费者购买汽车时，只需到工厂提货即可，无需自己再造一遍车。 ​ Car public interface Car&#123; public void name(); &#125; ​ Benz public class Benz implements Car&#123; @Override public void name()&#123; System.out.println(\"Benz car\"); &#125; &#125; ​ Tesla public class Tesla implements Car&#123; @Override public void name()&#123; System.out.println(\"Tesla car\"); &#125; &#125; ​ Factory public class CarFactory&#123; public static Car getCar(String name)&#123; if(\"Benz\".equals(name))&#123; return new Benz(); &#125;else if(\"Tesla\".equals(name))&#123; return new Tesla(); &#125; &#125; &#125; ​ Consumer public class Comsumer&#123; public static void main(String[] args)&#123; Car Benz = CarFactory.getCar(\"Benz\"); Car Tesla = CarFactory.getCar(\"Tesla\"); &#125; &#125; ​ 但是这种模式的弊端也尤为明显，当工厂新增生产线，生产新型号汽车时，则需要修改工厂的源代码，这是不利于扩展，维护的。此时，方法工厂模式应运而生。 方法工厂模式​ 例 ​ 这时，消费者购买心仪的汽车只需去到相应的工厂即可。 ​ Car public interface Car&#123; public void name(); &#125; ​ Benz public class Benz implements Car&#123; @Override public void name()&#123; System.out.println(\"Benz car\"); &#125; &#125; ​ Tesla public class Tesla implements Car&#123; @Override public void name()&#123; System.out.println(\"Tesla car\"); &#125; &#125; ​ Factory public interface Factory&#123; public Car getCar(); &#125; ​ BenzFactory public class BenzFactory implements Factory&#123; @Override public Car getCar()&#123; return new Benz(); &#125; &#125; ​ TeslaFactory public class TeslaFactory implements Factory&#123; @Override public Car getCar()&#123; return new Tesla(); &#125; &#125; ​ Consumer public class Comsumer&#123; public static void main(String[] args)&#123; Car Benz = BenzFactory.getCar(\"Benz\"); Car Tesla = TeslaFactory.getCar(\"Tesla\"); &#125; &#125; ​ 各个工厂各司其职，专心生产自己的东西，精益求精，努力追求匠人精神！ 抽象工厂模式​ 例 ​ Iphone public interface Iphone&#123; public void start(); public void end(); &#125; ​ Mi public class Mi implements Iphone&#123; @Override public void start()&#123; System.out.println(\"Mi iphone start.\") &#125; @Override public void end()&#123; System.out.println(\"Mi iphone end.\") &#125; &#125; ​ Honor public class Honor implements Iphone&#123; @Override public void start()&#123; System.out.println(\"Honor iphone start.\") &#125; @Override public void end()&#123; System.out.println(\"Honor iphone end.\") &#125; &#125; ​ Route public interface Route&#123; public void connect(); public void disConnect(); &#125; ​ MiRoute public class MiRoute implements MiRoute&#123; @Override publci void connect()&#123; System.out.println(\"MiRoute was connected\"); &#125; @Override publci void disconnect()&#123; System.out.println(\"MiRoute is disconnect\"); &#125; &#125; ​ HonorRoute public class HonorRoute implements MiRoute&#123; @Override publci void connect()&#123; System.out.println(\"HonorRoute was connected\"); &#125; @Override publci void disconnect()&#123; System.out.println(\"HonorRoute is disconnect\"); &#125; &#125; ​ Factory public interface Factory&#123; public Iphone getIphone(); public Route getRoute(); &#125; ​ MiFactory public class MiFactory implements Factory&#123; @Override public Iphone getIphone()&#123; return new Mi(); &#125; @Override public Route getRoute()&#123; return new MiRoute(); &#125; &#125; ​ HonorFactory ![builder](面试-2022-6-9/builder.png)public class HonorFactory implements Factory&#123; @Override public Iphone getIphone()&#123; return new Honor(); &#125; @Override public Route getRoute()&#123; return new HonorRoute(); &#125; &#125; ​ 这种模式适合固定的生产线，不添加新的生产线。 建造者模式​ 当多个方法互不干扰，相互独立的时候，可以包装到一个类中，之后进行组合。 ​ 例如点餐。可以自由搭配自己喜欢的菜品 ​ Product public class Product&#123; public String foodA; public String foodB; public String foodC; public String foodD; public Product()&#123; &#125; public void setFoodA(String food)&#123; foodA = food; &#125; public String getFoodA()&#123; return foodA; &#125; public void setFoodB(String food)&#123; foodB = food; &#125; public String getFoodB()&#123; return foodB; &#125; public void setFoodC(String food)&#123; foodC = food; &#125; public String getFoodC()&#123; return foodC; &#125; public void setFoodD(String food)&#123; foodD = food; &#125; public String getFoodD()&#123; return foodD; &#125; &#125; ​ Builder(抽象的Builder) public interface Builder&#123; /** * 返回值时原来的对象，可以使用链式编程。 */ public Product setFoodA(String food); public Product setFoodB(String food); public Product setFoodC(String food); public Product setFoodD(String food); public Product getProduct(); &#125; ​ Chef(具体的Builder) public class Chef implements Builder&#123; private Product product; public Chef()&#123; product = new Product(); &#125; @Override public Product setFoodA(String food)&#123; product.setFoodA(food); return product; &#125; @Override public Product setFoodB(String food)&#123; product.setFoodB(food); return product; &#125; @Override public Product setFoodC(String food)&#123; product.setFoodC(food); return product; &#125; @Override public Product setFoodD(String food)&#123; product.setFoodD(food); return product; &#125; @Override public Product getProduct()&#123; return Product(); &#125; &#125; ​ Director public class Director&#123; public Product build(Builder builder)&#123; builder.setFoodA(\"米饭\"); builder.setFoodA(\"肉末茄子\"); builder.setFoodA(\"地三鲜\"); builder.setFoodA(\"红烧肉\"); return builder.getProduct(); &#125; &#125; ​ Comsuer public class Test&#123; public static vodi main(String[] args)&#123; Builder chef = new Chef(); Product order = new Director(chef).build(); &#125; &#125; 适配器模式​ ​ Cable public class Cable&#123; publci void request()&#123; System.out.println(\"http request...\"); &#125; &#125; ​ NetToUSB public interface NetToUSB&#123; public void heandlerRequest(); &#125; ​ Adapter public class Adapter implements NetToUSB&#123; private Cable cable; public Adapter()&#123; cable = new Cable(); &#125; public Adapter(Cable cable)&#123; this.cable = cable; &#125; @Override public void heandlerRequest()&#123; cable.request(); &#125; &#125; ​ Computer public class Computer&#123; public void net(NetToUSB netToUSB)&#123; netToUSB.handlerRequest(); &#125; &#125; ​ Test public class Test&#123; public static void main(String[] args)&#123; Cable cable = new Cable(); Adapter adapter = new Adapter(cable); Computer.net(adapter); &#125; &#125; 桥接模式​ 华硕台式机，华硕笔记本，华硕平板，戴尔台式机，戴尔笔记本，戴尔平板…我们真的是创建六个类吗？ ​ 使用排列组合之后发现只需创建五个类（华硕，戴尔，台式机，笔记本，平板）。 ​ Brand public interface Brand&#123; public void info(); &#125; ​ ASUS public class ASUS implements Brand&#123; @Override public void info()&#123; System.out.print(\"华硕\"); &#125; &#125; ​ Dell public class Dell implements Brand&#123; @Override public void info()&#123; System.out.print(\"戴尔\"); &#125; &#125; ​ Station public interface Station&#123; public void info(); &#125; ​ DeskTop public class DeskTop implements Station&#123; private Brand brand; public DeskTop(Brand brand)&#123; this.brand = brand; &#125; @Override public void info()&#123; super.info(); System.out.println(\"台式机\"); &#125; &#125; ​ LapTop public class LapTop implements Station&#123; private Brand brand; public LapTop(Brand brand)&#123; this.brand = brand; &#125; @Override public void info()&#123; super.info(); System.out.println(\"笔记本\"); &#125; &#125; ​ TabletTop public class TabletTop implements Station&#123; private Brand brand; public TabletTop(Brand brand)&#123; this.brand = brand; &#125; @Override public void info()&#123; super.info(); System.out.println(\"平板\"); &#125; &#125; ​ Test public class Test&#123; public static void main(String[] args)&#123; Brand ASUS = new ASUS(); Brand Dell = new Dell(); Station asusDeskTop = new DeskTop(ASUS); Station asusLapTop = new LapTop(ASUS); Station asusTabletTop = new TabletTop(ASUS); Station dellDeskTop = new DeskTop(Dell); Station dellLapTop = new LapTop(Dell); Station dellTabletTop = new TabletTop(Dell); &#125; &#125; 静态代理动态代理","categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"排序","slug":"排序","date":"2022-06-08T03:57:01.000Z","updated":"2022-06-08T07:34:24.956Z","comments":true,"path":"2022/06/08/排序/","link":"","permalink":"http://example.com/2022/06/08/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"数据结构之排序归并排序归并排序是一种分而治之的思想。 例如一个数组 int[] arr = &#123;8,4,5,7,1,3,6,2&#125;; 通过不断二分，使得最小的数组长度为二，之后使用一个临时数组进行合并操作。 具体代码为： private static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int LEFT_END = mid+1; int RIGHT_END = right+1; int i = left; int j = LEFT_END; int t = left; //合并操作 while(i&lt;LEFT_END &amp;&amp; j&lt;RIGHT_END) &#123; if(arr[i] &lt; arr[j]) &#123; temp[t] = arr[i]; i++; &#125;else &#123; temp[t] = arr[j]; j++; &#125; t++; &#125; //若存在未满 while(i &lt; LEFT_END) &#123; temp[t++] = arr[i++]; &#125; //若存在未满 while(j &lt; RIGHT_END) &#123; temp[t++] = arr[j++]; &#125; //重新赋值给arr for(int index = left ; index &lt; RIGHT_END ; index++) &#123; arr[index] = temp[index]; &#125; &#125; public static int[] mergeSort(int[] arr, int left, int right, int[] temp) &#123; if(left &lt; right) &#123; int mid = left+(right-left)/2; //左划分 mergeSort(arr, left, mid, temp); //右划分 mergeSort(arr, mid+1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; return arr; &#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"面试-2022-5-30","slug":"面试-2022-5-30","date":"2022-06-04T15:41:10.000Z","updated":"2022-06-07T04:28:00.184Z","comments":true,"path":"2022/06/04/面试-2022-5-30/","link":"","permalink":"http://example.com/2022/06/04/%E9%9D%A2%E8%AF%95-2022-5-30/","excerpt":"","text":"Java八股文笔记（二）[TOC] 一、hashMap原理结构​ hashMap是由数组+链表组成的。 ​ 如上图可知，这是一个&#x3D;&#x3D;Entry&#x3D;&#x3D;节点数组，其中，&#x3D;&#x3D;Entry&#x3D;&#x3D;的源码为 static class Node&lt;K,V> implements Map.Entry&lt;K,V> &#123; final int hash; final K key; V value; Node&lt;K,V> next; ....... &#125; ​ 这是我们知道其内部有链表的结构，接着，在观察其&#x3D;&#x3D;put&#x3D;&#x3D;方法 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V> e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; &#125; ​ 观察第六行可以发现，&#x3D;&#x3D;tab&#x3D;&#x3D;数组是一个节点数组，在第七行的if中将老的&#x3D;&#x3D;table&#x3D;&#x3D;赋值给新生成的&#x3D;&#x3D;tab&#x3D;&#x3D;。而第九行的if中，&#x3D;&#x3D;i &#x3D; (n - 1) &amp; hash&#x3D;&#x3D;这个操作就是确定指针i处于第几个位置。而&#x3D;&#x3D;(n - 1) &amp; hash&#x3D;&#x3D;等同于&#x3D;&#x3D;hahs%n&#x3D;&#x3D;。if判断正确则当前指针指向地方无节点，直接插入即可。反之进入else在链表中插入。 ​ 通过观察源码，我们可以证实hashMap的结构的为数组加链表。 put方法​ put源码： public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i; /** * 将table赋值给新声明的tab，tab.length赋值给n。 * 若一者为true，那么table是一个空数组，这是调用resize方法，生成一个新的长度为16的node节点数组 */ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /** * (n - 1) &amp; hash等同于hash%n(二进制运算比取模快)，确定i的值。 * 判断为true那么数组位置i上无节点，直接new一个就行 */ if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V> e; K k; /** * 更新操作，存在key，那么将p赋值给e，随后更新e的value */ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; /** * 数组后连接的是红黑树的情况下，将节点插入红黑树 */ else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); else &#123; /** * 链表插入操作。 */ for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; &#125; final Node&lt;K,V>[] resize() &#123; Node&lt;K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) &#123; if (oldCap >= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr > 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V> e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V> loHead = null, loTail = null; Node&lt;K,V> hiHead = null, hiTail = null; Node&lt;K,V> next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; Node&lt;K,V> newNode(int hash, K key, V value, Node&lt;K,V> next) &#123; return new Node&lt;>(hash, key, value, next); &#125; ​ 通过观察其源码，我们可以知道其如何插入的原理。知道其如何确定数组位置，如何插入节点，以及存在相同key时的更新操作。 二、HashMap线程安全​ HashMap不是线程安全的，但在java5之后，有了一个线程安全的HashMap——ConcurrentHashMap。若是应用在多线程环境下，那么可以使用HashTable。 HashTable 是线程安全的。HashTable 容器使用 synchronized 来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下. 使用ConcurrentHashMap ，分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自ReentrantLock（可重入锁），这个小数组名叫Segment（JDK1.7） JDK1.8中取消了Segment 分段锁，采用 CAS + synchronized 来保证并发安全，ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点hash不冲突，就不会产生并发。 使用Collections.synchronizedMap方法，对方法进行加同步锁； 三、优先队列的是实现原理​ 普通的队列是先进先出的数据结构，而优先队列为元素赋予优先级，具有最高优先级的元素成为队列首部。 优先队列一般基于二叉堆实现。 二叉堆的基本原理什么是二叉堆 完全二叉树 堆的根节点的优先级最大（即最大或最小） 父节点的优先级必定大于子节点，兄弟节点的优先级不确定谁大谁小 堆的用途​ 取最值。 堆的基本操作 插入 往堆插入元素，基本思想是从最后一个位置开始，通过上浮操作不断调整位置，直到满足父节点的优先级必定大于子节点这个条件。 上浮 上浮是往二叉堆添加元素用到的操作，它其实是不断的调整k的位置为父元素的位置直到满足条件为止。 // 用数组表示堆 Object []objs = new Object[10]; /** * 上浮： * k表示堆的最后一个位置； * obj表示将要插入的元素。 */ private void siftUp(int k, Object obj) &#123; // 1. 判断k是否为根元素的位置0，如果是则直接赋值 while(k>0) &#123; // 2. 获取父元素的位置,parent = (k-1)/2 int parent = (k-1) >>> 1; // 3. 如果父元素的优先级大于等于obj，跳出循环并插入obj if(objs[parent] >= obj) &#123; break; &#125; // 4. 如果父元素的优先级小于obj，将父元素赋值到k的位置，更改k为父元素的位置，继续循环 objs[k] = objs[parent]; k = parent; &#125; // 5. 为obj赋值 objs[k] = obj; &#125; /** * 添加元素，不考虑数组扩容的情况。 * 假设size表示当前堆包含的元素个数（注意不一定等于上面定义的10） */ public void add(Object obj) &#123; if(size==0) &#123; objs[0] = obj; &#125; else &#123; siftUp(size, obj); size++; &#125; &#125; 删除 删除指定位置的元素，其基本思想是从指定位置开始，把最后一个元素放到被删除元素的位置，通过下沉或者上浮操作，使得堆满足父元素优先级大于子元素的条件。 下沉 下沉是删除时用到的操作。它是把最后一个元素放到被删除元素的位置，然后重新调整使得堆满足条件的过程。 当被删除元素的位置位于最后一个元素的父元素的位置后面时，可以直接把最后一个元素插入到被删除元素的位置；然后再进行上浮操作。 否则，需要执行下沉操作。 // 用数组表示堆 Object []objs = new Object[10]; /** * k被删除元素的位置； * obj堆的最后一个元素； * 假设size为当前堆包含元素的个数（不一定是上面定义的10） */ private void siftDown(int k, Object obj) &#123; // 1. 找到最后一个元素的父节点的位置, (最后一个元素位置-1) / 2 int parent = (size-1-1) >>> 1; // 2. 判断k是否在父节点位置之后，如果在之前则需要下沉操作 while(k &lt;= parent) &#123; // 3.获取k的左右子节点的位置 int left = k&lt;&lt;&lt;2 +1; int right = left+1; // 4.选择左右子节点中优先级最高的一个 int best; if (objs[left] > objs[right]) &#123; best = left; &#125; else &#123; best = right; &#125; // 5.判断obj和best的优先级谁高。如果obj优先级高，则跳出循环直接赋值，否则继续下沉 if (obj >= objs[best]) &#123; break; &#125; objs[k] = objs[best]; k = best; &#125; // 6.赋值 objs[k] = obj; &#125; /** * 删除第p个元素。 */ public void remove(int p) &#123; // 1.获取最后一个元素 Object obj = objs[size-1]; // 2.如果p不等于最后一个元素 if (p != size-1) &#123; // 3.把最后一个元素和p进行下沉操作 siftDown(p, obj); if(objs[p] == obj) &#123; // 4. 上浮 siftUp(p, obj); &#125; &#125; size--; &#125;","categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"面试-2022-5-18","slug":"面试-2022-5-18","date":"2022-06-04T12:50:53.000Z","updated":"2022-06-04T15:25:17.381Z","comments":true,"path":"2022/06/04/面试-2022-5-18/","link":"","permalink":"http://example.com/2022/06/04/%E9%9D%A2%E8%AF%95-2022-5-18/","excerpt":"","text":"Java八股文笔记（一）一、Final原理作用在变量上 基本类型变量 当一个final修饰基本类型变量时，变量需立即初始化，且之后不允许修改变量的值。所以一般用final修饰基本类型变量时都是常量，那么变量名全为大写。 final int STUDENT_AGE = 10; final char STUDENT_SEX = 'm'; 引用类型 当一个final修饰引用类型变量时，由于引用类型指向的是地址值，故对于当前变量的地址值之后无法修改，而地址值指向的内容是可以修改的。 private final Student wzj = new Student(\"wzj\", 18, m); private final int length = 3; 如下图所示 基本类型指向了常量的地址值，而引用类型指向的同样是地址值，但地址值中的东西可以修改。 作用在方法上作用在方法上时，若有子类继承此类，那么子类无法对该方法进行重载。一旦final修饰方法，那么在编译的时候已经静态绑定了，所以final方法比非final方法块。 作用在类上作用在类上时，表示该类无法被继承，那么final就不能修饰抽象类，这与抽象类的思想完全相反。若一个类修饰为final类，那么里面的方法默认为final方法。 final域的重排序先写入final变量，后调用该对象在构造函数对一个final对象的写入，与该构造函数被一个引用对象与引用，这之间不能重排序。 先读对象的引用，在读final变量读一个包含final域的对象，与读这个final变量，这之间不能重排序。 二、CMS与G1 的区别CMS垃圾收集说明 CMS是老年代并发GC算法：(ConcurrentMark-SweepGC、CMS GC)。 算法总体逻辑：标记-清除（Mark-Sweep) 流程总体流程为：初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并发清理。 详细流程如下： 初始标记（Initial Mark)（ STW ） 此阶段会暂停虚拟机（STW)，由根对象扫描出所有的关联对象，并做出标记。此过程只会导致JVM短暂暂停。 并发标记（Concurrent Marking) 恢复所有暂停的线程对象，并且对之前标记过的对象进行扫描，取得所有跟标记对象有关联的对象。 并发预清理（Concurrent Precleaning) 査找所有在并发标记阶段新进入老年代的对象(例如一些对象可能从新生代晋升到老年代，或者有一些对象被分配到老年代）通过重新扫描，减少下一阶段的工作。 重新标记（Remark)（ STW ） 此阶段会暂停虚拟机（STW），对在并发标记阶段被改变的引用或新创建的对象进行标记。 并发清理（Concurrent Sweeping) 恢复所有暂停的应用线程，对所有未标记的垃圾对象进行清理，并且尽量将己回收对象的空间重新拼凑为一个整体。在此阶段收集器线程和应用程序线程并发执行。 并发重置（Concurrent Reset) 重置CMS收集器的数据结构，等待下一次垃圾回收。 优点 支持并发收集。 低停顿。 垃圾收集过程中最耗时的并发标记和并发清除过程，CMS可以在这两个过程中和用户线程一起工作。所以，用户线程在这个时候就不用停下来了。 缺点 对CPU非常敏感。 在并发阶段虽然不会导致用户线程停顿，但是会占用了一部分线程，若CPU资源不足会使应用程序变慢。 无法处理浮动垃圾。 在最后一步并发清理过程中，用户线程执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉，这部分垃圾叫浮动垃圾。 由于并发清理的时候，用户线程也在运行，就需要保证用户线程在运行的时候需要留有部分内存以供使用。但是当这部分内存不足以给用户线程正常使用时，就会出现一次 “Concurrent Mode Failure”，一旦出现了“Concurrent Mode Failure”，便会开启后备方案，临时使用SerialOld收集器进行收集工作。 CMS使用“标记-清理”算法会产生大量的空间碎片。 当碎片过多，将会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。 新的JDK会逐渐移除CMS JDK9：将CMS标记为废弃（Depracated）。 JDK14：直接删除CMS G1垃圾收集流程说明 G1（Garbage-First）可以收集回收新生代和老年代。 G1垃圾收集器采用的是区域化、分布式的垃圾收集器。其核心思想是将整个堆内存区域划分成大小相同的子区域（Region)，在JVM启动时会自动设置这些子区域的大小（区域大小范围为1MB〜32MB，最多可以设置2048个区域，即支持的最大内存为32MB*2048&#x3D;65536MB&#x3D;64GB内存），这样Eden、Survivor、Tenured就变为了一系列不连续的内存区域，也就避免了全内存区的GC操作。G1收集器的内存分配如图1所示。 新生代的GC流程保存空间的大小会根据之前的对象大小进行重新计算。计算与对象的复制过程中依然会产生很短暂的暂停(STW),并且整个回收过程中会有多个回收线程并发收集。收集流程下图所示： 老年代的GC流程G1的老年代GC操作流程与CMS类似，并且在整个回收过程中依然会产生短暂的停顿。 初始标记（ STW ） 在此阶段会产生一个初始标记（InitialMark),此阶段会产生停顿（STW)，同时也会触发一次年轻代垃圾回收（MinorGC)，此时内存关系参考图1所示。 图1：初始化标记阶段 根区域（Region)扫描 在初始标记的存活区扫描对老年代的引用，并且对相关引用对象进行标记，该阶段与其他应用线程（非STW)同时运行。只有完成该阶段后，才能开始下一次STW年轻代垃圾回收。 并发标记 在堆内存中进行并发标记（与其他应用线程同时运行），在此过程中有可能被年轻代GC打断。 在此阶段，如果发现某一区域内全部为垃圾对象，那么会立即回收此区域的内存空间。而在此阶段也会计算每个区域的对象活跃度（该区域中存活对象的比例）。 此阶段内存关系如图2所示。 图2：并发标记阶段 重新标记（ STW ） 此阶段主要是用于收集并发标记阶段产生的垃圾空间产生短暂停顿（STW)。 G1收集器对该阶段使用了比CMS更高效的初始快照算法SATB(Snapshot-At-The-Beginning) 此阶段的内存关系如图3所示 图3：重新标记阶段 并行 清理（ STW ） 清理所有标记的垃圾内存空间，此阶段会产生短暂停顿（STW)。 此阶段会清除记录集合（RememberSets)并将空白区域重置。 复制阶段 将回收区域的存活对象复制到没有使用过的新区域（Region)。 清理复制阶段内存参考关系如图4所示。 图4：复制阶段 当整个操作执行完成后的内存关系如图5所示： 图5：G1老年代内存垃圾收集结束 特点1、并行与并发 ​ G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 2、分代收集 ​ 分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象、已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。 3、不产生内存碎片 ​ 由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。 4、可预测的停顿 ​ 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。 优点 不产生内存碎片 可指定最大停顿时间 这样可以让系统很少有较长的停顿时间。 对于短的停顿时间：G1 未必比 CMS短 对于长的停顿时间：G1 的长的停顿时间的次数比CMS少很多。 缺点 内存占用高 堆内存被划分为许多个小的Region分区数量，面对跨Region对象引用问题，每个Region分区都需要独立维护一份记忆集，使得用于维持G1正常运行的额外内存空间占到了总堆内存空间的10%~20%。 执行负载高 CMS用写后屏障来更新维护卡表 G1除了使用写后屏障来更新维护卡表外，为了实现原始快照搜索算法，还使用写前屏障来跟踪并发时的指针变化情况。 CMS与G1的区别 项 CMS（Concurrent Mark Sweep） G1（Garbage-First） 目的 获取最短回收停顿时间（牺牲吞吐量）。面向互联网网站或者B&#x2F;S服务端，减小停顿时间。 减少长停顿的次数、增加吞吐量。为了替代CMS（JDK11默认使用G1）。面向服务端应用。 回收的代 回收老年代 回收新生代和老年代 算法 标记-清除 从整体来看是“标记-整理”算法；从局部上来看“复制”算法 内存碎片 会产生内存碎片 不会产生内存碎片 过程 初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并发清理 初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并行清理 使用场景 资源较少（处理器少、内存小）。CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。 多核处理器、大内存。实时数据占用超过一半的堆空间。 对象分配或者晋升的速度变化大。 希望消除长时间的GC停顿（超过0.5-1秒）。 三、JVM调优通过前面的文章对JVM已经进行了简单的了解了，也知道了各种垃圾收集器以及其配置，那么这篇文章我们就简单地进行实例讲解了，如何进行JVM调优？JVM调优我们具体调整什么？为什么要调整这部分？怎么调整？ GC的评估指标进行JVM调优主要针对下面几个方面： 吞吐量： 吞吐量指的是运行用户代码占总时间的比例，它有一个计算公式为：吞吐量 &#x3D; 应用程序运行的时间&#x2F; (应用程序运行的时间 + GC回收的时间); 举个例子，假设程序运行时间为100s，GC垃圾回收时间为1秒，则吞吐量为100&#x2F;(1+100) &#x3D; 99%；如果这个值越小代表着垃圾回收占用的时间越多，GC垃圾回收占用时间多的原因就是堆内存不足导致垃圾回收的频率太多； GC负荷： GC负荷是与吞吐量相对的一个概念，指的是GC花费时间的百分比；其计算公式为：**GC负荷 &#x3D; GC回收的时间&#x2F; (应用程序运行的时间 + GC回收的时间)**。 响应时间： 这里的响应时间是GC执行垃圾回收时导致的STW的时间，这段时间除了GC其它所有线程都是停止的，当然我们期望的暂停时间越小越好。 GC频率： GC频率指的是在时间单位内GC进行垃圾回收的次数，当然GC频率与响应时间是反比的。假设堆内存一定的情况下，GC执行的频率越大代表着响应时间越小，而GC执行频率越小代表着响应时间越大。 反应速度： 反应速度指的是一个对象变成垃圾一直到被回收所耗费的时间。 在我们讲垃圾回收的时候讲了一个收集器Parallel收集器，这个收集器就是注重吞吐量的，这个收集器是JDK默认的垃圾回收器。响应时间优先的垃圾收集器，CMS收集器(老年代) &#x2F;ParNew(新生代)。G1收集器两者兼顾 怎么进行JVM调优上面简单的说明了几个GC性能进行评估的指标，在实际操作中我们主要以吞吐量、响应时间优先，所以最终JVM调优后的代码我们期望看到的是高吞吐量+低响应时间。 首先肯定需要考虑的是堆内存的大小，要合理的设置堆内存大小，怎么配置堆内存大小呢，这个可以借鉴腾讯云服务器给出的答案。这是腾讯云服务器选型，按照选型的参照有一定访问量的我们就按照2G设置，并发适中的4G设置，并发比较大的设置8G+。当然这个是服务器的内存大小，但是这个默认服务器只有我们的应用程序没有其他很耗费内存的应用。 第二点启动的时候堆内存初始值和最大值保持一致，防止内存不足垃圾回收后导致的内存扩大浪费时间，包括像新生代等有初始值和最大值的都尽量设置为同样的参数。 不要去主动的调用System.gc()方法，会导致垃圾回收，而且是Full GC的，触发STW机制。 设置大对象存放参数，超过的放在老年代，因为大对象比较大在新生代里面拷过来拷过去的很浪费性能，而且会导致GC频繁，设置参数为：**-XX:PretenureSizeThreshold**。 根据项目的情况合理的选择垃圾收集器，怎么选择垃圾收集器呢，这有个建议：还是按照上面的三种类型，2GB的使用Parallel收集器，这是以吞吐量优先的收集器，是默认的垃圾收集器，设置参数为 -XX:+UseParallelOldGC；对于4GB的使用CMS收集器，注重服务器的响应速度，系统停顿时间最短，设置参数为 -XX:+UseConcMarkSweepGC；对于8G甚至更大的使用G1收集器，将大内存设置成了多个小区域，而且回收按照区域优先级进行的，可以保证高吞吐量的同时做到低响应时间，设置参数为 -XX:+UseG1GC。 设置了不同的垃圾收集器还要根据实际的GC日志进行分析来调整其他参数进行调优。 这是最重要的一点，其实大多数情况是代码不合格。其实优化代码带来的性能提升远比优化JVM参数要大的多。 如何分析内存溢出问题先写个演示代，演示代码是一直进行死循环创建对象放到list中，这样创建的对象是可达的。 public static void main(String[] args) throws InterruptedException &#123; List list = new ArrayList(); while (true)&#123; list.add(new String(\"123\")); &#125; &#125; 123456 打开jvisualvm分析工具后选中我们写的程序，找到抽样器进行内存抽样，下面两个图为抽样结果首先看这张图，我们抽样出来的堆柱状图，这下面的列表是每种对象所使用的空间大小，没有告诉我们哪里导致的的内存溢出，但是我们可以得出结论创建的String对象太多导致了堆内存溢出。再选中每个线程分配看一下线程分配情况，这个列表是每个线程使用的堆内存大小，我们可以看到main线程占用了绝大部分的堆空间，几乎占满了，这个时候就可以定位到内存溢出可能是因为main线程创建了大量的String对象导致的，然后去排查main线程里面的代码是否有问题。这里其实可以看到一个阿里巴巴开发规范中的提到的规范：每个线程都要创建一个属于自己的名字。有了这个线程名字是不是就查找起来方便多了，要是一堆线程名叫Thread1、Thread2。。。看到这个也找不到导致内存溢出的线程。","categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"数组排序","slug":"数组排序","date":"2022-05-29T07:05:15.000Z","updated":"2022-05-29T09:30:53.671Z","comments":true,"path":"2022/05/29/数组排序/","link":"","permalink":"http://example.com/2022/05/29/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"数组排序一维数组排序对于排序，Java内置了工具类&#x3D;&#x3D;Arrays.sort&#x3D;&#x3D;,其内部原理使用的是快速排序算法，排序之后的结果为升序。 例如 对于int类型数组 int[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; 可以使用Arrays.sort进行排序 Arrays.sort(arr); 无需返回值，因为对arr本身进行操作。操作之后返回的结果为 arr=[1,2,3,4,5,6,7,8,9]; 同理，对于String类型数组也是同样的。 String[] strs = &#123;\"b\",\"d\",\"c\",\"a\"&#125;; Arrays.sort(strs); 排序之后的结果按照字典序升序进行排列 strs = [\"a\",\"b\",\"c\",\"d\"]; 那么问题来了，如果我想要的效果是大的排在前面——降序呢？该如何操作呢？ 这就涉及到了内部类与重写的操作了。 自定义排序通过观察java的api文档，对Arrays中的sort方法中，有一个参数&#x3D;&#x3D;Comparator&#x3D;&#x3D; `**sort**(T[] a, Comparator&lt;? super T> c)` 可以通过内部类，自定义比较规则。 例如，对String类型的一维数组降序 String[] strs = &#123;\"b\",\"d\",\"c\",\"a\"&#125;; Arrays.sort(strs, new Comparator&lt;String>()&#123; @Override public int compare(String o1, String o2)&#123; //字符串的比较使用String中的compareTo方法 //compareTo比较之后，结果返回1，表示大于，返回-1，表示小于。 return o2.compareTo(o1); &#125; &#125;); 那么，对于int类型数组是不是一样的操作呢？ int[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; Arrays.sort(arr, new Comparator&lt;int>()&#123; @Override public int compare(int o1, int o2)&#123; return o2-o1; &#125; &#125;); 然而却得到一个&#x3D;&#x3D;编译时异常&#x3D;&#x3D; 这是为什么呢？ 通过比较两代码发现，&#x3D;&#x3D;int&#x3D;&#x3D;属于基本数据类型，而String属于引用类型，故而将int转换为Integer Integer[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; Arrays.sort(arr, new Comparator&lt;Integer>()&#123; @Override public int parse(int o1, Integer o2)&#123; return o2-o1; &#125; &#125;); 完美运行~ 二维数组排序上面进行了一维数组的int类型和String类型的排序，那么对于二维数组呢，这又该怎么办呢？ 例如，leetcode第79场双周赛的第二题 经过处理后的到数组 String[][] sendAndWords = &#123;&#123;\"Alice\",\"5\"&#125;, &#123;\"UserTwo\",\"2\"&#125;, &#123;\"userThree\",\"3\"&#125;&#125;; //其中sendAndWords第一列表示的是用户，第二列表示发送的单词数。 /**需求为 1、输出单词数最多的用户。 2、若单词数相同，则按名字字典序最大的输出。 */ 那么我们对这个二维数组的操作为先对第二列降序，在第二列相同的情况下对第一列降序。 利用上面一维数组的思想 String[][] sendAndWords = &#123;&#123;\"Alice\",\"5\"&#125;, &#123;\"UserTwo\",\"2\"&#125;, &#123;\"userThree\",\"3\"&#125;&#125;; Arrays.sort(sendAndWords, new Comparator&lt;String[]>() &#123; @Override public int compare(String[] o1, String[] o2) &#123; // 若单词数相同，那么按照用户名字典序降序 if (o2[1].equals(o1[1])) &#123; return o2[0].compareTo(o1[0]); &#125; // 按单词数降序。 return o2[1].compareTo(o1[1]); &#125; &#125;); 完美运行~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"部署hexo","slug":"部署hexo","date":"2022-05-27T15:48:22.000Z","updated":"2022-05-28T13:14:15.256Z","comments":true,"path":"2022/05/27/部署hexo/","link":"","permalink":"http://example.com/2022/05/27/%E9%83%A8%E7%BD%B2hexo/","excerpt":"部署hexo环境配置：git，nodejsgit（Windows版本） 登录&#x3D;&#x3D;git&#x3D;&#x3D;官网 https://git-scm.com/ 点击&#x3D;&#x3D;downloads&#x3D;&#x3D;下载","text":"部署hexo环境配置：git，nodejsgit（Windows版本） 登录&#x3D;&#x3D;git&#x3D;&#x3D;官网 https://git-scm.com/ 点击&#x3D;&#x3D;downloads&#x3D;&#x3D;下载 点击&#x3D;&#x3D;Windows&#x3D;&#x3D; 按电脑位数选择版本 打开cmd（管理员身份运行）命令行 #查看安装版本，以此校验git安装是否成功 git --version nodejs（Windows版本） 前往官网下载&#x3D;&#x3D;nodejs&#x3D;&#x3D; https://nodejs.org/zh-cn/download/ 下载完成后点击安装 安装nodejs，直接点下一步，直至安装完成。 检验安装是否成功 #查看nodejs版本，检验安装是否成功 node -v 安装hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 hexo init &lt;folder&gt; #将hexo初始化在folder文件夹中 cd &lt;folder&gt; npm install 测试运行在cmd中运行 hexo s #一定要在hexo的根目录中，及folder文件夹中 主题更换（yilia） 根目录下打开&#x3D;&#x3D;git bash&#x3D;&#x3D; 输入 git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 修改根目录下的&#x3D;&#x3D;_config.yml&#x3D;&#x3D;配置 将&#x3D;&#x3D;theme&#x3D;&#x3D;的值修改为&#x3D;&#x3D;yilia&#x3D;&#x3D; 三连（hexo clean,g,d）查看效果 头像设置 打开&#x3D;&#x3D;yilia&#x3D;&#x3D;下的&#x3D;&#x3D;_config.yml&#x3D;&#x3D;，修改&#x3D;&#x3D;avatar&#x3D;&#x3D;(头像)和&#x3D;&#x3D;favicon&#x3D;&#x3D;(选项卡图标) 此时的路径为相对路径，绝对路径为hexo根目录下的source中。故在source文件夹中放入文件 三连查看效果 部署遇到的问题hexo d失败 swapd文件错误 解决办法： 进入hexo的根目录 删除&#x3D;&#x3D;.deploy_git&#x3D;&#x3D;文件 在根目录右键打开&#x3D;&#x3D;git bash&#x3D;&#x3D; 重新部署 hexo clean hexo g hexo d 网络不稳定 多尝试几次即可。 md中图片不显示 进入hexo的根目录 修改&#x3D;&#x3D;_config.yml&#x3D;&#x3D;的配置，找到&#x3D;&#x3D;post_asset_folder&#x3D;&#x3D;，其默认为&#x3D;&#x3D;false&#x3D;&#x3D;，将其修改为&#x3D;&#x3D;true&#x3D;&#x3D;。 （此后，通过&#x3D;&#x3D;hexo new&#x3D;&#x3D;一个新的文件时，会在文件的同级目录下生成一个同名的文件夹，hexo生成页面时，将其一起打包进一个文件夹中。故接下来要修改md的图片位置） 打开Typora，点击&#x3D;&#x3D;文件&#x3D;&#x3D;-&gt;&#x3D;&#x3D;偏好设置&#x3D;&#x3D;-&gt;&#x3D;&#x3D;图片插入&#x3D;&#x3D;，修改为下图所示。 此时再次三连(hexo clean, hexo g, hexo d)即可。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-26T14:45:46.986Z","updated":"2022-05-26T14:45:46.986Z","comments":true,"path":"2022/05/26/hello-world/","link":"","permalink":"http://example.com/2022/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}