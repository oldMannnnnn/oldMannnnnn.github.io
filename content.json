{"meta":{"title":"王智坚的秘密空间","subtitle":"","description":"","author":"王智坚","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-05-30T14:16:18.000Z","updated":"2022-05-30T14:17:18.300Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"面试-2022-5-18","slug":"面试-2022-5-18","date":"2022-06-04T12:50:53.000Z","updated":"2022-06-04T15:25:17.381Z","comments":true,"path":"2022/06/04/面试-2022-5-18/","link":"","permalink":"http://example.com/2022/06/04/%E9%9D%A2%E8%AF%95-2022-5-18/","excerpt":"","text":"Java八股文笔记（一）一、Final原理作用在变量上 基本类型变量 当一个final修饰基本类型变量时，变量需立即初始化，且之后不允许修改变量的值。所以一般用final修饰基本类型变量时都是常量，那么变量名全为大写。 final int STUDENT_AGE = 10; final char STUDENT_SEX = 'm'; 引用类型 当一个final修饰引用类型变量时，由于引用类型指向的是地址值，故对于当前变量的地址值之后无法修改，而地址值指向的内容是可以修改的。 private final Student wzj = new Student(\"wzj\", 18, m); private final int length = 3; 如下图所示 基本类型指向了常量的地址值，而引用类型指向的同样是地址值，但地址值中的东西可以修改。 作用在方法上作用在方法上时，若有子类继承此类，那么子类无法对该方法进行重载。一旦final修饰方法，那么在编译的时候已经静态绑定了，所以final方法比非final方法块。 作用在类上作用在类上时，表示该类无法被继承，那么final就不能修饰抽象类，这与抽象类的思想完全相反。若一个类修饰为final类，那么里面的方法默认为final方法。 final域的重排序先写入final变量，后调用该对象在构造函数对一个final对象的写入，与该构造函数被一个引用对象与引用，这之间不能重排序。 先读对象的引用，在读final变量读一个包含final域的对象，与读这个final变量，这之间不能重排序。 二、CMS与G1 的区别CMS垃圾收集说明 CMS是老年代并发GC算法：(ConcurrentMark-SweepGC、CMS GC)。 算法总体逻辑：标记-清除（Mark-Sweep) 流程总体流程为：初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并发清理。 详细流程如下： 初始标记（Initial Mark)（ STW ） 此阶段会暂停虚拟机（STW)，由根对象扫描出所有的关联对象，并做出标记。此过程只会导致JVM短暂暂停。 并发标记（Concurrent Marking) 恢复所有暂停的线程对象，并且对之前标记过的对象进行扫描，取得所有跟标记对象有关联的对象。 并发预清理（Concurrent Precleaning) 査找所有在并发标记阶段新进入老年代的对象(例如一些对象可能从新生代晋升到老年代，或者有一些对象被分配到老年代）通过重新扫描，减少下一阶段的工作。 重新标记（Remark)（ STW ） 此阶段会暂停虚拟机（STW），对在并发标记阶段被改变的引用或新创建的对象进行标记。 并发清理（Concurrent Sweeping) 恢复所有暂停的应用线程，对所有未标记的垃圾对象进行清理，并且尽量将己回收对象的空间重新拼凑为一个整体。在此阶段收集器线程和应用程序线程并发执行。 并发重置（Concurrent Reset) 重置CMS收集器的数据结构，等待下一次垃圾回收。 优点 支持并发收集。 低停顿。 垃圾收集过程中最耗时的并发标记和并发清除过程，CMS可以在这两个过程中和用户线程一起工作。所以，用户线程在这个时候就不用停下来了。 缺点 对CPU非常敏感。 在并发阶段虽然不会导致用户线程停顿，但是会占用了一部分线程，若CPU资源不足会使应用程序变慢。 无法处理浮动垃圾。 在最后一步并发清理过程中，用户线程执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉，这部分垃圾叫浮动垃圾。 由于并发清理的时候，用户线程也在运行，就需要保证用户线程在运行的时候需要留有部分内存以供使用。但是当这部分内存不足以给用户线程正常使用时，就会出现一次 “Concurrent Mode Failure”，一旦出现了“Concurrent Mode Failure”，便会开启后备方案，临时使用SerialOld收集器进行收集工作。 CMS使用“标记-清理”算法会产生大量的空间碎片。 当碎片过多，将会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC。 新的JDK会逐渐移除CMS JDK9：将CMS标记为废弃（Depracated）。 JDK14：直接删除CMS G1垃圾收集流程说明 G1（Garbage-First）可以收集回收新生代和老年代。 G1垃圾收集器采用的是区域化、分布式的垃圾收集器。其核心思想是将整个堆内存区域划分成大小相同的子区域（Region)，在JVM启动时会自动设置这些子区域的大小（区域大小范围为1MB〜32MB，最多可以设置2048个区域，即支持的最大内存为32MB*2048&#x3D;65536MB&#x3D;64GB内存），这样Eden、Survivor、Tenured就变为了一系列不连续的内存区域，也就避免了全内存区的GC操作。G1收集器的内存分配如图1所示。 新生代的GC流程保存空间的大小会根据之前的对象大小进行重新计算。计算与对象的复制过程中依然会产生很短暂的暂停(STW),并且整个回收过程中会有多个回收线程并发收集。收集流程下图所示： 老年代的GC流程G1的老年代GC操作流程与CMS类似，并且在整个回收过程中依然会产生短暂的停顿。 初始标记（ STW ） 在此阶段会产生一个初始标记（InitialMark),此阶段会产生停顿（STW)，同时也会触发一次年轻代垃圾回收（MinorGC)，此时内存关系参考图1所示。 图1：初始化标记阶段 根区域（Region)扫描 在初始标记的存活区扫描对老年代的引用，并且对相关引用对象进行标记，该阶段与其他应用线程（非STW)同时运行。只有完成该阶段后，才能开始下一次STW年轻代垃圾回收。 并发标记 在堆内存中进行并发标记（与其他应用线程同时运行），在此过程中有可能被年轻代GC打断。 在此阶段，如果发现某一区域内全部为垃圾对象，那么会立即回收此区域的内存空间。而在此阶段也会计算每个区域的对象活跃度（该区域中存活对象的比例）。 此阶段内存关系如图2所示。 图2：并发标记阶段 重新标记（ STW ） 此阶段主要是用于收集并发标记阶段产生的垃圾空间产生短暂停顿（STW)。 G1收集器对该阶段使用了比CMS更高效的初始快照算法SATB(Snapshot-At-The-Beginning) 此阶段的内存关系如图3所示 图3：重新标记阶段 并行 清理（ STW ） 清理所有标记的垃圾内存空间，此阶段会产生短暂停顿（STW)。 此阶段会清除记录集合（RememberSets)并将空白区域重置。 复制阶段 将回收区域的存活对象复制到没有使用过的新区域（Region)。 清理复制阶段内存参考关系如图4所示。 图4：复制阶段 当整个操作执行完成后的内存关系如图5所示： 图5：G1老年代内存垃圾收集结束 特点1、并行与并发 ​ G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 2、分代收集 ​ 分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象、已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。 3、不产生内存碎片 ​ 由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。 4、可预测的停顿 ​ 降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。 优点 不产生内存碎片 可指定最大停顿时间 这样可以让系统很少有较长的停顿时间。 对于短的停顿时间：G1 未必比 CMS短 对于长的停顿时间：G1 的长的停顿时间的次数比CMS少很多。 缺点 内存占用高 堆内存被划分为许多个小的Region分区数量，面对跨Region对象引用问题，每个Region分区都需要独立维护一份记忆集，使得用于维持G1正常运行的额外内存空间占到了总堆内存空间的10%~20%。 执行负载高 CMS用写后屏障来更新维护卡表 G1除了使用写后屏障来更新维护卡表外，为了实现原始快照搜索算法，还使用写前屏障来跟踪并发时的指针变化情况。 CMS与G1的区别 项 CMS（Concurrent Mark Sweep） G1（Garbage-First） 目的 获取最短回收停顿时间（牺牲吞吐量）。面向互联网网站或者B&#x2F;S服务端，减小停顿时间。 减少长停顿的次数、增加吞吐量。为了替代CMS（JDK11默认使用G1）。面向服务端应用。 回收的代 回收老年代 回收新生代和老年代 算法 标记-清除 从整体来看是“标记-整理”算法；从局部上来看“复制”算法 内存碎片 会产生内存碎片 不会产生内存碎片 过程 初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并发清理 初始标记&#x3D;&gt; 并发标记&#x3D;&gt; 重新标记&#x3D;&gt; 并行清理 使用场景 资源较少（处理器少、内存小）。CMS 在小内存应用上的表现要优于 G1，而大内存应用上 G1 更有优势，大小内存的界限是6GB到8GB。 多核处理器、大内存。实时数据占用超过一半的堆空间。 对象分配或者晋升的速度变化大。 希望消除长时间的GC停顿（超过0.5-1秒）。 三、JVM调优通过前面的文章对JVM已经进行了简单的了解了，也知道了各种垃圾收集器以及其配置，那么这篇文章我们就简单地进行实例讲解了，如何进行JVM调优？JVM调优我们具体调整什么？为什么要调整这部分？怎么调整？ GC的评估指标进行JVM调优主要针对下面几个方面： 吞吐量： 吞吐量指的是运行用户代码占总时间的比例，它有一个计算公式为：吞吐量 &#x3D; 应用程序运行的时间&#x2F; (应用程序运行的时间 + GC回收的时间); 举个例子，假设程序运行时间为100s，GC垃圾回收时间为1秒，则吞吐量为100&#x2F;(1+100) &#x3D; 99%；如果这个值越小代表着垃圾回收占用的时间越多，GC垃圾回收占用时间多的原因就是堆内存不足导致垃圾回收的频率太多； GC负荷： GC负荷是与吞吐量相对的一个概念，指的是GC花费时间的百分比；其计算公式为：**GC负荷 &#x3D; GC回收的时间&#x2F; (应用程序运行的时间 + GC回收的时间)**。 响应时间： 这里的响应时间是GC执行垃圾回收时导致的STW的时间，这段时间除了GC其它所有线程都是停止的，当然我们期望的暂停时间越小越好。 GC频率： GC频率指的是在时间单位内GC进行垃圾回收的次数，当然GC频率与响应时间是反比的。假设堆内存一定的情况下，GC执行的频率越大代表着响应时间越小，而GC执行频率越小代表着响应时间越大。 反应速度： 反应速度指的是一个对象变成垃圾一直到被回收所耗费的时间。 在我们讲垃圾回收的时候讲了一个收集器Parallel收集器，这个收集器就是注重吞吐量的，这个收集器是JDK默认的垃圾回收器。响应时间优先的垃圾收集器，CMS收集器(老年代) &#x2F;ParNew(新生代)。G1收集器两者兼顾 怎么进行JVM调优上面简单的说明了几个GC性能进行评估的指标，在实际操作中我们主要以吞吐量、响应时间优先，所以最终JVM调优后的代码我们期望看到的是高吞吐量+低响应时间。 首先肯定需要考虑的是堆内存的大小，要合理的设置堆内存大小，怎么配置堆内存大小呢，这个可以借鉴腾讯云服务器给出的答案。这是腾讯云服务器选型，按照选型的参照有一定访问量的我们就按照2G设置，并发适中的4G设置，并发比较大的设置8G+。当然这个是服务器的内存大小，但是这个默认服务器只有我们的应用程序没有其他很耗费内存的应用。 第二点启动的时候堆内存初始值和最大值保持一致，防止内存不足垃圾回收后导致的内存扩大浪费时间，包括像新生代等有初始值和最大值的都尽量设置为同样的参数。 不要去主动的调用System.gc()方法，会导致垃圾回收，而且是Full GC的，触发STW机制。 设置大对象存放参数，超过的放在老年代，因为大对象比较大在新生代里面拷过来拷过去的很浪费性能，而且会导致GC频繁，设置参数为：**-XX:PretenureSizeThreshold**。 根据项目的情况合理的选择垃圾收集器，怎么选择垃圾收集器呢，这有个建议：还是按照上面的三种类型，2GB的使用Parallel收集器，这是以吞吐量优先的收集器，是默认的垃圾收集器，设置参数为 -XX:+UseParallelOldGC；对于4GB的使用CMS收集器，注重服务器的响应速度，系统停顿时间最短，设置参数为 -XX:+UseConcMarkSweepGC；对于8G甚至更大的使用G1收集器，将大内存设置成了多个小区域，而且回收按照区域优先级进行的，可以保证高吞吐量的同时做到低响应时间，设置参数为 -XX:+UseG1GC。 设置了不同的垃圾收集器还要根据实际的GC日志进行分析来调整其他参数进行调优。 这是最重要的一点，其实大多数情况是代码不合格。其实优化代码带来的性能提升远比优化JVM参数要大的多。 如何分析内存溢出问题先写个演示代，演示代码是一直进行死循环创建对象放到list中，这样创建的对象是可达的。 public static void main(String[] args) throws InterruptedException &#123; List list = new ArrayList(); while (true)&#123; list.add(new String(\"123\")); &#125; &#125; 123456 打开jvisualvm分析工具后选中我们写的程序，找到抽样器进行内存抽样，下面两个图为抽样结果首先看这张图，我们抽样出来的堆柱状图，这下面的列表是每种对象所使用的空间大小，没有告诉我们哪里导致的的内存溢出，但是我们可以得出结论创建的String对象太多导致了堆内存溢出。再选中每个线程分配看一下线程分配情况，这个列表是每个线程使用的堆内存大小，我们可以看到main线程占用了绝大部分的堆空间，几乎占满了，这个时候就可以定位到内存溢出可能是因为main线程创建了大量的String对象导致的，然后去排查main线程里面的代码是否有问题。这里其实可以看到一个阿里巴巴开发规范中的提到的规范：每个线程都要创建一个属于自己的名字。有了这个线程名字是不是就查找起来方便多了，要是一堆线程名叫Thread1、Thread2。。。看到这个也找不到导致内存溢出的线程。","categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"}]},{"title":"数组排序","slug":"数组排序","date":"2022-05-29T07:05:15.000Z","updated":"2022-05-29T09:30:53.671Z","comments":true,"path":"2022/05/29/数组排序/","link":"","permalink":"http://example.com/2022/05/29/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"数组排序一维数组排序对于排序，Java内置了工具类&#x3D;&#x3D;Arrays.sort&#x3D;&#x3D;,其内部原理使用的是快速排序算法，排序之后的结果为升序。 例如 对于int类型数组 int[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; 可以使用Arrays.sort进行排序 Arrays.sort(arr); 无需返回值，因为对arr本身进行操作。操作之后返回的结果为 arr=[1,2,3,4,5,6,7,8,9]; 同理，对于String类型数组也是同样的。 String[] strs = &#123;\"b\",\"d\",\"c\",\"a\"&#125;; Arrays.sort(strs); 排序之后的结果按照字典序升序进行排列 strs = [\"a\",\"b\",\"c\",\"d\"]; 那么问题来了，如果我想要的效果是大的排在前面——降序呢？该如何操作呢？ 这就涉及到了内部类与重写的操作了。 自定义排序通过观察java的api文档，对Arrays中的sort方法中，有一个参数&#x3D;&#x3D;Comparator&#x3D;&#x3D; `**sort**(T[] a, Comparator&lt;? super T> c)` 可以通过内部类，自定义比较规则。 例如，对String类型的一维数组降序 String[] strs = &#123;\"b\",\"d\",\"c\",\"a\"&#125;; Arrays.sort(strs, new Comparator&lt;String>()&#123; @Override public int compare(String o1, String o2)&#123; //字符串的比较使用String中的compareTo方法 //compareTo比较之后，结果返回1，表示大于，返回-1，表示小于。 return o2.compareTo(o1); &#125; &#125;); 那么，对于int类型数组是不是一样的操作呢？ int[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; Arrays.sort(arr, new Comparator&lt;int>()&#123; @Override public int compare(int o1, int o2)&#123; return o2-o1; &#125; &#125;); 然而却得到一个&#x3D;&#x3D;编译时异常&#x3D;&#x3D; 这是为什么呢？ 通过比较两代码发现，&#x3D;&#x3D;int&#x3D;&#x3D;属于基本数据类型，而String属于引用类型，故而将int转换为Integer Integer[] arr = &#123;9,7,8,2,4,3,6,1,5&#125;; Arrays.sort(arr, new Comparator&lt;Integer>()&#123; @Override public int parse(int o1, Integer o2)&#123; return o2-o1; &#125; &#125;); 完美运行~ 二维数组排序上面进行了一维数组的int类型和String类型的排序，那么对于二维数组呢，这又该怎么办呢？ 例如，leetcode第79场双周赛的第二题 经过处理后的到数组 String[][] sendAndWords = &#123;&#123;\"Alice\",\"5\"&#125;, &#123;\"UserTwo\",\"2\"&#125;, &#123;\"userThree\",\"3\"&#125;&#125;; //其中sendAndWords第一列表示的是用户，第二列表示发送的单词数。 /**需求为 1、输出单词数最多的用户。 2、若单词数相同，则按名字字典序最大的输出。 */ 那么我们对这个二维数组的操作为先对第二列降序，在第二列相同的情况下对第一列降序。 利用上面一维数组的思想 String[][] sendAndWords = &#123;&#123;\"Alice\",\"5\"&#125;, &#123;\"UserTwo\",\"2\"&#125;, &#123;\"userThree\",\"3\"&#125;&#125;; Arrays.sort(sendAndWords, new Comparator&lt;String[]>() &#123; @Override public int compare(String[] o1, String[] o2) &#123; // 若单词数相同，那么按照用户名字典序降序 if (o2[1].equals(o1[1])) &#123; return o2[0].compareTo(o1[0]); &#125; // 按单词数降序。 return o2[1].compareTo(o1[1]); &#125; &#125;); 完美运行~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"部署hexo","slug":"部署hexo","date":"2022-05-27T15:48:22.000Z","updated":"2022-05-28T13:14:15.256Z","comments":true,"path":"2022/05/27/部署hexo/","link":"","permalink":"http://example.com/2022/05/27/%E9%83%A8%E7%BD%B2hexo/","excerpt":"部署hexo环境配置：git，nodejsgit（Windows版本） 登录&#x3D;&#x3D;git&#x3D;&#x3D;官网 https://git-scm.com/ 点击&#x3D;&#x3D;downloads&#x3D;&#x3D;下载","text":"部署hexo环境配置：git，nodejsgit（Windows版本） 登录&#x3D;&#x3D;git&#x3D;&#x3D;官网 https://git-scm.com/ 点击&#x3D;&#x3D;downloads&#x3D;&#x3D;下载 点击&#x3D;&#x3D;Windows&#x3D;&#x3D; 按电脑位数选择版本 打开cmd（管理员身份运行）命令行 #查看安装版本，以此校验git安装是否成功 git --version nodejs（Windows版本） 前往官网下载&#x3D;&#x3D;nodejs&#x3D;&#x3D; https://nodejs.org/zh-cn/download/ 下载完成后点击安装 安装nodejs，直接点下一步，直至安装完成。 检验安装是否成功 #查看nodejs版本，检验安装是否成功 node -v 安装hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 npm install -g hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 hexo init &lt;folder&gt; #将hexo初始化在folder文件夹中 cd &lt;folder&gt; npm install 测试运行在cmd中运行 hexo s #一定要在hexo的根目录中，及folder文件夹中 主题更换（yilia） 根目录下打开&#x3D;&#x3D;git bash&#x3D;&#x3D; 输入 git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 修改根目录下的&#x3D;&#x3D;_config.yml&#x3D;&#x3D;配置 将&#x3D;&#x3D;theme&#x3D;&#x3D;的值修改为&#x3D;&#x3D;yilia&#x3D;&#x3D; 三连（hexo clean,g,d）查看效果 头像设置 打开&#x3D;&#x3D;yilia&#x3D;&#x3D;下的&#x3D;&#x3D;_config.yml&#x3D;&#x3D;，修改&#x3D;&#x3D;avatar&#x3D;&#x3D;(头像)和&#x3D;&#x3D;favicon&#x3D;&#x3D;(选项卡图标) 此时的路径为相对路径，绝对路径为hexo根目录下的source中。故在source文件夹中放入文件 三连查看效果 部署遇到的问题hexo d失败 swapd文件错误 解决办法： 进入hexo的根目录 删除&#x3D;&#x3D;.deploy_git&#x3D;&#x3D;文件 在根目录右键打开&#x3D;&#x3D;git bash&#x3D;&#x3D; 重新部署 hexo clean hexo g hexo d 网络不稳定 多尝试几次即可。 md中图片不显示 进入hexo的根目录 修改&#x3D;&#x3D;_config.yml&#x3D;&#x3D;的配置，找到&#x3D;&#x3D;post_asset_folder&#x3D;&#x3D;，其默认为&#x3D;&#x3D;false&#x3D;&#x3D;，将其修改为&#x3D;&#x3D;true&#x3D;&#x3D;。 （此后，通过&#x3D;&#x3D;hexo new&#x3D;&#x3D;一个新的文件时，会在文件的同级目录下生成一个同名的文件夹，hexo生成页面时，将其一起打包进一个文件夹中。故接下来要修改md的图片位置） 打开Typora，点击&#x3D;&#x3D;文件&#x3D;&#x3D;-&gt;&#x3D;&#x3D;偏好设置&#x3D;&#x3D;-&gt;&#x3D;&#x3D;图片插入&#x3D;&#x3D;，修改为下图所示。 此时再次三连(hexo clean, hexo g, hexo d)即可。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-26T14:45:46.986Z","updated":"2022-05-26T14:45:46.986Z","comments":true,"path":"2022/05/26/hello-world/","link":"","permalink":"http://example.com/2022/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java八股文","slug":"Java八股文","permalink":"http://example.com/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}